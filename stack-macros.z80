;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; data stack
;;
;; the top of the stack (TOS) is stored in register BC for efficiency
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; macros for literal and immediate data

.macro _peek, regHI, regLO                  ; x -- x ; rp = x
    ld regLO, C
    ld regHI, B                             ; move TOS reg pair into register pair
.endm

.macro _poke, regHI, regLO                  ; rp = x ; y -- x
    ld C, regLO
    ld B, regHI                             ; move TOS reg pair into register pair
.endm

.macro _nipInto, regHI, regLO               ; x y -- y ; rep = x
    dec IX                                  ; POP register pair
    dec IX
    ld regHI, (IX+1)
    ld regLO, (IX+0)
.endm

.macro _tuckFrom, regHI, regLO              ; rp = x; y -- x y
    ld (IX+0), regLO                        ; PUSH register pair
    ld (IX+1), regHI
    inc IX
    inc IX
.endm

.macro _overInto, regHI, regLO              ; x y -- y  rp = x
    ld regLO, (IX-2)
    ld regHI, (IX-1)                        ; move TOS reg pair into register pair
.endm

.macro _push, src                           ; put src (value or memory) location on top of param stack
    call dup
    ld BC, src
.endm

.macro _pop, dest                           ; put top of param stack into dest
    ld dest, BC
    call drop
.endm

.macro _pushChar, char
    call dup
    ld B,0
    ld C,char
.endm

.macro _pushStr, str, len
    _push tpt_text%%M
    _push len
    _skip
tpt_text%%M:
        db str
    _endskip
.endm

.macro _pushPStr, s1
    _push tpt_text%%M
    ld BC, tpt_text%%M
    _skip
tpt_text%%M:
        .pstr s1
    _endskip
.endm

; less common macros

.macro _tuck                                ; x y -- y x y
    _peek H,L
    call drop
    _tuckFrom H,L
.endm

.macro _over2                               ;x1a x1b x2a x2b -- x1a x1b x2a x2b x1a x1b
    call dup2
    _poke (IX-9),(IX-10)
    _peek (IX-1),(IX-2)
    _poke (IX-7),(IX-8)
.endm

; swap the top two items of data stack
.macro _swap2                               ; x1a x1b x2a x2b -- x2a x2b x1a x1b
    push DE
    _alter2x -1,-5
    _alter2x -2,-6
    _alter2 -4,C
    _alter2 -3,B
    pop DE
.endm

; rot top three items, third from top ends up on top of data stack
.macro _rot                                 ; x1 x2 x3 -- x2 x3 x1
    push DE
    _alter3 -2,C,-4
    _alter3 -1,B,-3
    pop DE
.endm

; rot top three items, third from top ends up on top of data stack
; destroys: AF'
.macro _rot2                                ; x1a x1b x2a x2b x3a x3b -- x2a x2b x3a x3b x1a x1b
    push DE
    _alter3x -6,-2,-10
    _alter3x -5,-1,-9
    _alter3 -4,C,-8
    _alter3 -3,B,-7
    pop DE
.endm

; reverse rot top three items, top of data stack becomes third from top  stack
; destroys: AF'
.macro _nrot                                ; x1 x2 x3 -- x3 x1 x2
    push DE
    _alter3 -4,C,-2
    _alter3 -3,B,-1
    pop DE
.endm

; rot top three items, third from top ends up on top of data stack
; destroys: AF',DE
.macro _nrot2                               ; x1a x1b x2a x2b x3a x3b -- x3a x3b x1a x1b x2a x2b
    push DE

    _alter3x -10,-2,-6
    _alter3x -9,-1,-5
    _alter3 -8,C,-4
    _alter3 -7,B,-3

    pop DE
.endm

.macro _toRetStack
    push BC
    call drop
.endm

.macro _fromRetStack
    call dup
    pop BC
.endm

.macro _min                                 ; x1 x2 -- x
    _peek H,L
    _peek D,E                               ; make a copy of x2
    call drop
    or A
    sbc HL,BC
    jr nc, L_%%M
    _poke  D,E
L_%%M:
.endm

.macro _max                                 ; x1 x2 -- x
    _peek H,L
    _peek D,E                               ; make a copy of x2
    call drop
    or A
    sbc HL,BC
    jr c, L_%%M
    _poke  D,E
L_%%M:
.endm

; divide by 2
.macro _div2                                 ; n -- n
    srl B
    rr C
.endm

.macro _ifZero
    call isZero
    jp z, L_%%M
    jp $              ; placeholder jump to _else or _endif
    STRUC_PUSH $
L_%%M:
.endm

.macro _ifNotZero
    call isZero
    jp nz, L_%%M
    jp $              ; placeholder jump to _else or _endif
    STRUC_PUSH $
L_%%M:
.endm

.macro _untilZero
    call isZero
    jp z, DLOOP_TOP - 3  ; jump to jump to enddo
    DLOOP_FWD               ; needed?
.endm

.macro _untilNotZero
    call isZero
    jp nz, DLOOP_TOP - 3  ; jump to jump to enddo
    DLOOP_FWD               ; needed?
.endm

.macro _isNegative
    bit 7,A
.endm

