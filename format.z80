formatNum:                              ; ptr num -- ptr len
    push IY
    _pop H,L                            ; HL = num, BC = TOS = ptr

    ld IY,0
    add IY,BC                           ; copy BC to IY
    _dup                                ; save BC for later

    ld A,0
    bit 7, H                            ; Detect sign of HL.
    _if nz
        ld A, '-'                       ; Output '-' to string and negate HL.
        ld (IY+0), A
        inc IY
        call negateNum
        ld A,1
    _endif
    ex AF,AF'                           ; save sign in A prime

    ld BC,(VAR_BASE)                    ; C = BASE
    ld B, 0                             ; B will count character length of number
    _do
        push BC
        call divideWordByByte           ; HL = HL / A, A = remainder
        pop BC
        push AF                         ; pushes digits on stack
        inc B
        checkZeroWord H,L
    _until z
    _enddo

    ld C,B                              ; copy B count in C
    _do
        pop AF                          ; pops digits off stack
        add A,$30                       ; convert digit to ASCII
        cp $3A
        _if nc
            add A,7
        _endif
        ld (IY+0), A
        inc IY
    _djnz
                                        ; B = 0, BC = count
    ex AF,AF'                           ; if sign negative increase count
    add A,C
    ld C,A
                                        ; ptr count
    pop IY
    ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; negate ***
; params: HL = number
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

negateNum:
    ; Negate HL (using two's complement)
    xor A
    sub L
    ld L, A
    ld A, 0     ; Note that xor A or SUB A would disturb CF
    sbc A, H
    ld H, A
    ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; divide word by byte ***
; params: HL = dividend, C = divisor
; returns: HL = result, A = remainder
; destroys: ?
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

divideWordByByte:

    ld B, 16
    xor A
    _do
        add HL, HL
        rla
        _if c
            sub C
            inc L
        _else
            cp C
            _if nc
                sub C
                inc L
            _endif
        _endif
    _djnz
    ret

divideWordByByte1:                  ; dividend divisor -- result remainder
    _pop0 H,L
    ld B, 16                        ; we only use the 8-bits in C as divisor
    xor A
    _do
        add HL, HL
        rla
        _if c
            sub C
            inc L
        _else
            cp C
            _if nc
                sub C
                inc L
            _endif
        _endif
    _djnz
    _push0 H,L                      ; push result
    ld C,A                          ; tos = remainder
    ld B,0
    ret

