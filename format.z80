defword "formatNum", 0, formatNum       ; ptr num -- ptr len
    _overInto H,L                       ; HL = ptr, BC = num
    _tuckFrom H,L                       ; ptr ptr num
    bit 7, B                            ; Detect sign of HL.
    _if nz
        call negateNum                  ; ptr ptr num1
        _swap                           ; ptr num1 ptr
        ld A, '-'                       ; Output '-' to string and negate HL.
        writeByte BC, A
        _swap                           ; ptr ptr' num1
    _endif
    _pushValue (VAR_BASE)               ; ptr ptr' num1 base
    _swap                               ; ptr ptr' base num1
    ld D, 0                             ; D counter
    _do
        inc D
        call over                       ; ptr ptr' base num1 base
        push DE
        call divideWord                 ; ptr ptr' base num2 rem
        pop DE
        _toRetStack                     ; ptr ptr' base num2
        call dup                            ; ptr ptr' base num2 num2
        _isZero                         ; ptr ptr' base num2
    _until z
    _enddo
    _drop2                              ; ptr ptr'
    _do
        _fromRetStack                   ; ptr ptr' digit
        ld A,$30
        add A,C                         ; convert TOS digit to ASCII
        cp $3A
        _if nc
            add A,7
        _endif
        call drop                           ; ptr ptr'
        writeByte BC, A
        dec D
    _until z
    _enddo
    _pop H,L                            ; HL = ptr' BC = ptr
    call dup                                ; ptr ptr
    or A
    sbc HL, BC
    loadWord B,C, H,L                   ; ptr len
    ret

