defword "formatNum", 0, formatNum       ; ptr num -- ptr len
    _overInto H,L                       ; HL = ptr, BC = num
    _tuckFrom H,L                       ; ptr ptr num
    bit 7, B                            ; Detect sign of HL.
    _if nz
        call negateNum                  ; ptr ptr num1
        _swap                           ; ptr num1 ptr
        ld A, '-'                       ; Output '-' to string and negate HL.
        ld (BC),A
        inc BC
        _swap                           ; ptr ptr' num1
    _endif
    _pushValue (VAR_BASE)               ; ptr ptr' num1 base
    _swap                               ; ptr ptr' base num1
    ld D, 0                             ; D counter
    _do
        inc D
        call over                       ; ptr ptr' base num1 base
        push DE
        call divideWord                 ; ptr ptr' base num2 rem
        pop DE
        _toRetStack                     ; ptr ptr' base num2
        call dup                            ; ptr ptr' base num2 num2
        _isZero                         ; ptr ptr' base num2
    _until z
    _enddo
    _drop2                              ; ptr ptr'
    _do
        _fromRetStack                   ; ptr ptr' digit
        ld A,$30
        add A,C                         ; convert TOS digit to ASCII
        cp $3A
        _if nc
            add A,7
        _endif
        call drop                       ; ptr ptr'
        ld (BC),A
        inc BC
        dec D
    _until z
    _enddo
    _load H,L, B,C                      ; HL = ptr'
    call dropdup                        ; ptr ptr
    or A
    sbc HL, BC
    _load B,C, H,L                      ; ptr len
    ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; toNumber -  converts string to number in the ***
; base strored in VAR_BASE
;
; params: HL = string address, BC = string length
; returns: DE = parsed number, BC = 0: success, not 0, uparsed chars
; destroys: AF
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

toNumber:                               ; str len -- num err
    call dup                            ; str len len
    _isZero                             ; if zero then return 0 0
    _if z                               ; str zero
        _nip                            ; zero
        call dup                        ; zero zero
        ret                             ; -- 0 0 
    _endif
    _overInto H,L                       ; str len ; HL = str
    ld A,(HL)                           ; A = char
    cp '-'                              ; is A negative number?
    _if z
        inc HL
        dec BC                          ; str len
        call dup                        ; str len len
        _isZero
        _if z                           ; str zero
            _nip                        ; zero
            call dup                    ; zero zero
            ld BC,1
            ret                         ; -- 0 1
        _else
            ld A,(HL)                   ; str len ; A = char
        _endIf
    _endIf
    _pushValue 0                        ; str len num(0)
    _do
        sub '0'                         ; < '0'?
        _until c                            ; invalid char, end of number
        cp 10                           ; <= '9'?
        _if nc
            sub 17                      ; < 'A'? (17 is 'A'-'0')
    _until c            
            add A,10
        _endif
        call dup                        ; str len num num
        ld BC, (VAR_BASE)               ; str len num base
        cp C                            ; > base
        call drop                       ; str len num
    _until nc
        add A,C                         ; str len num (num += A)                      
        ld C,A
        xor A
        adc A,B
        ld B,A
        _swap                           ; str num len
        dec BC                          ; str num len (len--) 
        call dup                        ; str num len len
        _isZero                         ; str num len 
        _swap                           ; str len num
    _until z
        call dup                        ; str len num num
        ld BC, (VAR_BASE)               ; str len num base
        push HL
        call unsignedMultiply           ; str len num num2 (num *= BASE)
        pop HL
        call drop                       ; str len num
        inc HL
        ld A,(HL)                       ; a = next char
    _enddo
    _nip                                ; str num
    _swap                               ; num str
    ld A,(BC)
    cp "-"
    call drop                               ; num
    _if z
        call negateNum                  ; num
    _endif
    call dup
    _pushValue 0                        ; num 0
    ret
