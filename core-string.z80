; destroys: HL
compareStr:                             ; str1 str2 len -- (-1|0|1)
    call dup
    call isZero                         ; test for Count=0
    ret z
    call swap                           ; str1 len str2
    _pop HL                             ; str1 len      HL = str2 c = len 
    ld A,C                              ; str1 len      HL = sr2 A = len
    ex af,af'
    ld A,B                              ; str1 len      HL = sr2 A:A' = len
    call drop                           ; str1          HL = sr2 A = len 
    push DE                             ; save DE       suspend forth
    ld D,B                              
    ld E,C                              ; str1          HL = sr2 DE = str1 B = len 
    ld B,A
    ex af,af'
    ld C,A                              ; len
compstr1:
    ld A,(DE)
    inc DE
    cpi
    jr z,compstr3                   ; char mismatch: exit
    dec HL                      ; point at mismatch char
    cp (HL)                     ; set carry if char1 < char2
    jr nc,compstr2
    ld BC, -1               ; -1 str1 < str2
    jr compstr4
compstr2:
    ld BC, 1                ; 1 str1 > str2
    jr compstr4
compstr3:
    jp pe,compstr1
    ld BC,0                             ; 0 no mismatch found
compstr4:
    pop DE                              ; restore DE resume forth
    ret

; ; next ( -- ) ( r: idx ret ) followed by address of loop start
; ; Run time code for the single index loop.
; ; r> r> dup if 1 - >r @ >r exit then drop cell+ >r ;
; CODE 'next',0,DONXT         
;             _rfrom          ; ret ( r: idx )   
;             _rfrom          ; ret idx 
;             call dup        ; ret idx idx
;             call isZero     
;             jr nz,DONXT1    
;             dec BC          ; ret idx'
;             _tor            ; ret (r: idx')
;             call fetch      ; ret' (r: idx')
;             _tor            ; (r: idx' ret')
;             ret             ; jump to ret' (start of loop)
; DONXT1:
;             call drop       ; ret
;             inc BC          
;             inc BC          ; ret+2
;             _tor            ; (r: ret+2)
;             ret             ; jump to ret+2 (after offset)


