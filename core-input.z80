initInput:
    ld HL, linebuf
    ld (lineBufStart), HL
    ld (currkey), HL
    ld (linebuftop), HL
    ld HL, LINE_BUFSIZE
    ld (lineBufSize), HL
    ret

    CODE "KEY",0,KEY
getKey:
    push BC
    ld HL, (currkey)
    ld BC, (lineBufTop)
    or A
    sbc HL,BC                  ; exhausted the input lineBuf?
    jr c,getKey1

    call getline
    ld HL, lineBuf
    ld (currkey), HL
    or A
    adc HL, BC              ; lineBuf+DE = lineBufTop
    ld (lineBufTop),HL
getKey1:
    ld HL, (currkey)
    ld A,(HL)               ; get next key from input lineBuf
    inc HL
    ld (currkey),HL         ; increment currkey
    pop BC
    call dup
    _setTOS 0,A
    ret

; getline - input line of text ***
; returns: BC = length - up to 255

getline:
    _pushPStr "\r\n> "
    call printPStr
    ld HL, lineBuf
    ld BC, 0
getline1:    
    call getc
    cp $08
    jr nz,getline4
    call dup
    call isZero
    jr z,getline1
    dec HL
    dec BC
    ld a, $08
    call putc
    ld A," "
    call putc
    ld A, $08
    call putc
    jr getline1
getline4:
    ld (HL), A
    inc HL
    inc BC
    bit 7,a
    jr nz,getline5
    call putc
getline5:
    cp "\r"
    jr z, getline7
    cp "\n"
    jr z, getline7
    ld A, LINE_BUFSIZE-1
    cp C
    jr c, getline7
    jr getline1
getline7:
    ld a, 0
    cp c
    jr z,getline1
    call printCR
    ret
