;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; dictionary routines
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; defword "find",0,FIND                   ; ptr len -- ptrOrZero

;     _popNext H,L                        ; HL = ptr, BC = TOS = len
    
;     ld DE, (VAR_LATEST)                 ; search dictionary backwards from LATEST
;     _do
;         checkZeroWord D,E               ; NULL pointer?  (end of the linked list)
;         _if z
;             _break
;         _endif

;         ; compareStr the length expected and the length of the word.
;         ; Note that if the MSK_HIDDEN flag is set on the word, then by a bit of trickery
;         ; this won't pick the word (the length will appear to be wrong).

;         push DE                         ; save ptr to header

;         inc DE                          ; skip over first field
;         inc DE
;         ld A, (DE)                      ; a = flags
;         and FLAG_HIDDEN | FLAG_LENGTH   ;  = name length

;         cp C                            ; Length is the same?
;         _if z
;                                         ; compareStr the strings in detail.
;             inc DE                      ; DE = Dictionary string we are checking against.

;             push HL                     ; save HL, BC
;             push BC
;             call compareStr                ; compareStr the strings. BC = len
;             pop BC
;             pop HL

;             or A                        ; if A == 0 then matched
;             _if z
;                 pop DE                  ; matched, restore DE and return
;                 _break
;             _endif

;         _endif
;         pop DE                          ; restore DE
;         ld A,(DE)
;         ex AF,AF'
;         inc DE
;         ld A,(DE)
;         ld D,A
;         ex AF,AF'
;         ld E,A
;     _enddo

;     loadWord B,C, D,E                   ; move to TOS
;     ret

defword "compare", 0, compareStr        ; str1 len1 str2 len2 -- (-1|0|1) 
    _rot                                ; str1 str2 len2 len1  
    _min                                ; str1 str2 len
    _popNext H,L
    _popNext D,E
    checkZeroWord B,C                   ; test for Count=0
    ret z
    _do
        ld A,(DE)
        inc DE
        cpi
        _if nz                          ; char mismatch: exit
            dec HL                      ; point at mismatch char
            cp (HL)                     ; set carry if char1 < char2
            _if c
                ld BC, -1
            _else
                ld BC, 1
            _endif
            ret
        _endif
    _until po
    _enddo
    ld BC,0                             ; count exhausted & no mismatch found
    ret

